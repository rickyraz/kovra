// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transfers.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createTransfer = `-- name: CreateTransfer :one
INSERT INTO transfers (
    tenant_id, source_legal_entity_id, dest_legal_entity_id, quote_id, recipient_id,
    idempotency_key, from_currency, to_currency, from_amount, to_amount, fx_rate, total_fee, rail
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, tenant_id, source_legal_entity_id, dest_legal_entity_id, quote_id, batch_id, recipient_id,
    idempotency_key, from_currency, to_currency, from_amount, to_amount, fx_rate, total_fee,
    status, failure_reason, rail, rail_reference, netting_group_id, is_netted,
    tb_transfer_ids, risk_score, compliance_status, screened_at, compliance_region,
    updated_at, completed_at
`

type CreateTransferParams struct {
	TenantID            uuid.UUID      `json:"tenant_id"`
	SourceLegalEntityID pgtype.UUID    `json:"source_legal_entity_id"`
	DestLegalEntityID   pgtype.UUID    `json:"dest_legal_entity_id"`
	QuoteID             pgtype.UUID    `json:"quote_id"`
	RecipientID         pgtype.UUID    `json:"recipient_id"`
	IdempotencyKey      pgtype.Text    `json:"idempotency_key"`
	FromCurrency        string         `json:"from_currency"`
	ToCurrency          string         `json:"to_currency"`
	FromAmount          pgtype.Numeric `json:"from_amount"`
	ToAmount            pgtype.Numeric `json:"to_amount"`
	FxRate              pgtype.Numeric `json:"fx_rate"`
	TotalFee            pgtype.Numeric `json:"total_fee"`
	Rail                NullRailEnum   `json:"rail"`
}

func (q *Queries) CreateTransfer(ctx context.Context, arg CreateTransferParams) (Transfer, error) {
	row := q.db.QueryRow(ctx, createTransfer,
		arg.TenantID,
		arg.SourceLegalEntityID,
		arg.DestLegalEntityID,
		arg.QuoteID,
		arg.RecipientID,
		arg.IdempotencyKey,
		arg.FromCurrency,
		arg.ToCurrency,
		arg.FromAmount,
		arg.ToAmount,
		arg.FxRate,
		arg.TotalFee,
		arg.Rail,
	)
	var i Transfer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SourceLegalEntityID,
		&i.DestLegalEntityID,
		&i.QuoteID,
		&i.BatchID,
		&i.RecipientID,
		&i.IdempotencyKey,
		&i.FromCurrency,
		&i.ToCurrency,
		&i.FromAmount,
		&i.ToAmount,
		&i.FxRate,
		&i.TotalFee,
		&i.Status,
		&i.FailureReason,
		&i.Rail,
		&i.RailReference,
		&i.NettingGroupID,
		&i.IsNetted,
		&i.TbTransferIds,
		&i.RiskScore,
		&i.ComplianceStatus,
		&i.ScreenedAt,
		&i.ComplianceRegion,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getTransferByID = `-- name: GetTransferByID :one
SELECT id, tenant_id, source_legal_entity_id, dest_legal_entity_id, quote_id, batch_id, recipient_id,
    idempotency_key, from_currency, to_currency, from_amount, to_amount, fx_rate, total_fee,
    status, failure_reason, rail, rail_reference, netting_group_id, is_netted,
    tb_transfer_ids, risk_score, compliance_status, screened_at, compliance_region,
    updated_at, completed_at
FROM transfers
WHERE id = $1
`

func (q *Queries) GetTransferByID(ctx context.Context, id uuid.UUID) (Transfer, error) {
	row := q.db.QueryRow(ctx, getTransferByID, id)
	var i Transfer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SourceLegalEntityID,
		&i.DestLegalEntityID,
		&i.QuoteID,
		&i.BatchID,
		&i.RecipientID,
		&i.IdempotencyKey,
		&i.FromCurrency,
		&i.ToCurrency,
		&i.FromAmount,
		&i.ToAmount,
		&i.FxRate,
		&i.TotalFee,
		&i.Status,
		&i.FailureReason,
		&i.Rail,
		&i.RailReference,
		&i.NettingGroupID,
		&i.IsNetted,
		&i.TbTransferIds,
		&i.RiskScore,
		&i.ComplianceStatus,
		&i.ScreenedAt,
		&i.ComplianceRegion,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getTransferByIdempotencyKey = `-- name: GetTransferByIdempotencyKey :one
SELECT id, tenant_id, source_legal_entity_id, dest_legal_entity_id, quote_id, batch_id, recipient_id,
    idempotency_key, from_currency, to_currency, from_amount, to_amount, fx_rate, total_fee,
    status, failure_reason, rail, rail_reference, netting_group_id, is_netted,
    tb_transfer_ids, risk_score, compliance_status, screened_at, compliance_region,
    updated_at, completed_at
FROM transfers
WHERE tenant_id = $1 AND idempotency_key = $2
`

type GetTransferByIdempotencyKeyParams struct {
	TenantID       uuid.UUID   `json:"tenant_id"`
	IdempotencyKey pgtype.Text `json:"idempotency_key"`
}

func (q *Queries) GetTransferByIdempotencyKey(ctx context.Context, arg GetTransferByIdempotencyKeyParams) (Transfer, error) {
	row := q.db.QueryRow(ctx, getTransferByIdempotencyKey, arg.TenantID, arg.IdempotencyKey)
	var i Transfer
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.SourceLegalEntityID,
		&i.DestLegalEntityID,
		&i.QuoteID,
		&i.BatchID,
		&i.RecipientID,
		&i.IdempotencyKey,
		&i.FromCurrency,
		&i.ToCurrency,
		&i.FromAmount,
		&i.ToAmount,
		&i.FxRate,
		&i.TotalFee,
		&i.Status,
		&i.FailureReason,
		&i.Rail,
		&i.RailReference,
		&i.NettingGroupID,
		&i.IsNetted,
		&i.TbTransferIds,
		&i.RiskScore,
		&i.ComplianceStatus,
		&i.ScreenedAt,
		&i.ComplianceRegion,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const listTransfersByTenant = `-- name: ListTransfersByTenant :many
SELECT id, tenant_id, source_legal_entity_id, dest_legal_entity_id, quote_id, batch_id, recipient_id,
    idempotency_key, from_currency, to_currency, from_amount, to_amount, fx_rate, total_fee,
    status, failure_reason, rail, rail_reference, netting_group_id, is_netted,
    tb_transfer_ids, risk_score, compliance_status, screened_at, compliance_region,
    updated_at, completed_at
FROM transfers
WHERE tenant_id = $1
    AND ($4::transfer_status_enum IS NULL OR status = $4)
    AND ($5::text IS NULL OR from_currency = $5)
    AND ($6::text IS NULL OR to_currency = $6)
    AND ($7::text IS NULL OR compliance_region = $7)
    AND ($8::timestamptz IS NULL OR updated_at >= $8)
    AND ($9::timestamptz IS NULL OR updated_at < $9)
ORDER BY updated_at DESC
LIMIT $2 OFFSET $3
`

type ListTransfersByTenantParams struct {
	TenantID         uuid.UUID              `json:"tenant_id"`
	Limit            int32                  `json:"limit"`
	Offset           int32                  `json:"offset"`
	Status           NullTransferStatusEnum `json:"status"`
	FromCurrency     pgtype.Text            `json:"from_currency"`
	ToCurrency       pgtype.Text            `json:"to_currency"`
	ComplianceRegion pgtype.Text            `json:"compliance_region"`
	UpdatedAfter     pgtype.Timestamptz     `json:"updated_after"`
	UpdatedBefore    pgtype.Timestamptz     `json:"updated_before"`
}

func (q *Queries) ListTransfersByTenant(ctx context.Context, arg ListTransfersByTenantParams) ([]Transfer, error) {
	rows, err := q.db.Query(ctx, listTransfersByTenant,
		arg.TenantID,
		arg.Limit,
		arg.Offset,
		arg.Status,
		arg.FromCurrency,
		arg.ToCurrency,
		arg.ComplianceRegion,
		arg.UpdatedAfter,
		arg.UpdatedBefore,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transfer{}
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SourceLegalEntityID,
			&i.DestLegalEntityID,
			&i.QuoteID,
			&i.BatchID,
			&i.RecipientID,
			&i.IdempotencyKey,
			&i.FromCurrency,
			&i.ToCurrency,
			&i.FromAmount,
			&i.ToAmount,
			&i.FxRate,
			&i.TotalFee,
			&i.Status,
			&i.FailureReason,
			&i.Rail,
			&i.RailReference,
			&i.NettingGroupID,
			&i.IsNetted,
			&i.TbTransferIds,
			&i.RiskScore,
			&i.ComplianceStatus,
			&i.ScreenedAt,
			&i.ComplianceRegion,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransfersByTenantAndStatus = `-- name: ListTransfersByTenantAndStatus :many
SELECT id, tenant_id, source_legal_entity_id, dest_legal_entity_id, quote_id, batch_id, recipient_id,
    idempotency_key, from_currency, to_currency, from_amount, to_amount, fx_rate, total_fee,
    status, failure_reason, rail, rail_reference, netting_group_id, is_netted,
    tb_transfer_ids, risk_score, compliance_status, screened_at, compliance_region,
    updated_at, completed_at
FROM transfers
WHERE tenant_id = $1 AND status = $2
ORDER BY updated_at DESC
LIMIT $3 OFFSET $4
`

type ListTransfersByTenantAndStatusParams struct {
	TenantID uuid.UUID          `json:"tenant_id"`
	Status   TransferStatusEnum `json:"status"`
	Limit    int32              `json:"limit"`
	Offset   int32              `json:"offset"`
}

func (q *Queries) ListTransfersByTenantAndStatus(ctx context.Context, arg ListTransfersByTenantAndStatusParams) ([]Transfer, error) {
	rows, err := q.db.Query(ctx, listTransfersByTenantAndStatus,
		arg.TenantID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transfer{}
	for rows.Next() {
		var i Transfer
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.SourceLegalEntityID,
			&i.DestLegalEntityID,
			&i.QuoteID,
			&i.BatchID,
			&i.RecipientID,
			&i.IdempotencyKey,
			&i.FromCurrency,
			&i.ToCurrency,
			&i.FromAmount,
			&i.ToAmount,
			&i.FxRate,
			&i.TotalFee,
			&i.Status,
			&i.FailureReason,
			&i.Rail,
			&i.RailReference,
			&i.NettingGroupID,
			&i.IsNetted,
			&i.TbTransferIds,
			&i.RiskScore,
			&i.ComplianceStatus,
			&i.ScreenedAt,
			&i.ComplianceRegion,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransferComplianceStatus = `-- name: UpdateTransferComplianceStatus :exec
UPDATE transfers
SET compliance_status = $2, risk_score = $3, screened_at = NOW(), updated_at = NOW()
WHERE id = $1
`

type UpdateTransferComplianceStatusParams struct {
	ID               uuid.UUID   `json:"id"`
	ComplianceStatus string      `json:"compliance_status"`
	RiskScore        pgtype.Int4 `json:"risk_score"`
}

func (q *Queries) UpdateTransferComplianceStatus(ctx context.Context, arg UpdateTransferComplianceStatusParams) error {
	_, err := q.db.Exec(ctx, updateTransferComplianceStatus, arg.ID, arg.ComplianceStatus, arg.RiskScore)
	return err
}

const updateTransferNetting = `-- name: UpdateTransferNetting :exec
UPDATE transfers
SET netting_group_id = $2, is_netted = $3, updated_at = NOW()
WHERE id = $1
`

type UpdateTransferNettingParams struct {
	ID             uuid.UUID   `json:"id"`
	NettingGroupID pgtype.UUID `json:"netting_group_id"`
	IsNetted       bool        `json:"is_netted"`
}

func (q *Queries) UpdateTransferNetting(ctx context.Context, arg UpdateTransferNettingParams) error {
	_, err := q.db.Exec(ctx, updateTransferNetting, arg.ID, arg.NettingGroupID, arg.IsNetted)
	return err
}

const updateTransferRailReference = `-- name: UpdateTransferRailReference :exec
UPDATE transfers
SET rail_reference = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateTransferRailReferenceParams struct {
	ID            uuid.UUID   `json:"id"`
	RailReference pgtype.Text `json:"rail_reference"`
}

func (q *Queries) UpdateTransferRailReference(ctx context.Context, arg UpdateTransferRailReferenceParams) error {
	_, err := q.db.Exec(ctx, updateTransferRailReference, arg.ID, arg.RailReference)
	return err
}

const updateTransferStatus = `-- name: UpdateTransferStatus :exec
UPDATE transfers
SET status = $2, failure_reason = $3, updated_at = NOW(),
    completed_at = CASE WHEN $2 IN ('completed', 'rolled_back', 'cancelled', 'rejected') THEN NOW() ELSE completed_at END
WHERE id = $1
`

type UpdateTransferStatusParams struct {
	ID            uuid.UUID          `json:"id"`
	Status        TransferStatusEnum `json:"status"`
	FailureReason pgtype.Text        `json:"failure_reason"`
}

func (q *Queries) UpdateTransferStatus(ctx context.Context, arg UpdateTransferStatusParams) error {
	_, err := q.db.Exec(ctx, updateTransferStatus, arg.ID, arg.Status, arg.FailureReason)
	return err
}

const updateTransferTBTransferIDs = `-- name: UpdateTransferTBTransferIDs :exec
UPDATE transfers
SET tb_transfer_ids = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateTransferTBTransferIDsParams struct {
	ID            uuid.UUID        `json:"id"`
	TbTransferIds []pgtype.Numeric `json:"tb_transfer_ids"`
}

func (q *Queries) UpdateTransferTBTransferIDs(ctx context.Context, arg UpdateTransferTBTransferIDsParams) error {
	_, err := q.db.Exec(ctx, updateTransferTBTransferIDs, arg.ID, arg.TbTransferIds)
	return err
}
