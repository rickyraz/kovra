// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tenants.sql

package queries

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createTenant = `-- name: CreateTenant :one
INSERT INTO tenants (display_name, legal_name, country, tenant_kind, parent_tenant_id, legal_entity_id, metadata)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, display_name, legal_name, country, tenant_kind, parent_tenant_id, legal_entity_id,
    tenant_status, kyc_level, netting_enabled, netting_window_minutes,
    api_key_hash, webhook_url, webhook_secret_hash, metadata, updated_at
`

type CreateTenantParams struct {
	DisplayName    string         `json:"display_name"`
	LegalName      string         `json:"legal_name"`
	Country        string         `json:"country"`
	TenantKind     TenantKindEnum `json:"tenant_kind"`
	ParentTenantID pgtype.UUID    `json:"parent_tenant_id"`
	LegalEntityID  uuid.UUID      `json:"legal_entity_id"`
	Metadata       []byte         `json:"metadata"`
}

func (q *Queries) CreateTenant(ctx context.Context, arg CreateTenantParams) (Tenant, error) {
	row := q.db.QueryRow(ctx, createTenant,
		arg.DisplayName,
		arg.LegalName,
		arg.Country,
		arg.TenantKind,
		arg.ParentTenantID,
		arg.LegalEntityID,
		arg.Metadata,
	)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.LegalName,
		&i.Country,
		&i.TenantKind,
		&i.ParentTenantID,
		&i.LegalEntityID,
		&i.TenantStatus,
		&i.KycLevel,
		&i.NettingEnabled,
		&i.NettingWindowMinutes,
		&i.ApiKeyHash,
		&i.WebhookUrl,
		&i.WebhookSecretHash,
		&i.Metadata,
		&i.UpdatedAt,
	)
	return i, err
}

const getTenantByID = `-- name: GetTenantByID :one
SELECT id, display_name, legal_name, country, tenant_kind, parent_tenant_id, legal_entity_id,
    tenant_status, kyc_level, netting_enabled, netting_window_minutes,
    api_key_hash, webhook_url, webhook_secret_hash, metadata, updated_at
FROM tenants
WHERE id = $1
`

func (q *Queries) GetTenantByID(ctx context.Context, id uuid.UUID) (Tenant, error) {
	row := q.db.QueryRow(ctx, getTenantByID, id)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.LegalName,
		&i.Country,
		&i.TenantKind,
		&i.ParentTenantID,
		&i.LegalEntityID,
		&i.TenantStatus,
		&i.KycLevel,
		&i.NettingEnabled,
		&i.NettingWindowMinutes,
		&i.ApiKeyHash,
		&i.WebhookUrl,
		&i.WebhookSecretHash,
		&i.Metadata,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveTenants = `-- name: ListActiveTenants :many
SELECT id, display_name, legal_name, country, tenant_kind, parent_tenant_id, legal_entity_id,
    tenant_status, kyc_level, netting_enabled, netting_window_minutes,
    api_key_hash, webhook_url, webhook_secret_hash, metadata, updated_at
FROM tenants
WHERE tenant_status = 'active'
ORDER BY id DESC
LIMIT $1 OFFSET $2
`

type ListActiveTenantsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListActiveTenants(ctx context.Context, arg ListActiveTenantsParams) ([]Tenant, error) {
	rows, err := q.db.Query(ctx, listActiveTenants, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tenant{}
	for rows.Next() {
		var i Tenant
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.LegalName,
			&i.Country,
			&i.TenantKind,
			&i.ParentTenantID,
			&i.LegalEntityID,
			&i.TenantStatus,
			&i.KycLevel,
			&i.NettingEnabled,
			&i.NettingWindowMinutes,
			&i.ApiKeyHash,
			&i.WebhookUrl,
			&i.WebhookSecretHash,
			&i.Metadata,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTenantsByLegalEntity = `-- name: ListTenantsByLegalEntity :many
SELECT id, display_name, legal_name, country, tenant_kind, parent_tenant_id, legal_entity_id,
    tenant_status, kyc_level, netting_enabled, netting_window_minutes,
    api_key_hash, webhook_url, webhook_secret_hash, metadata, updated_at
FROM tenants
WHERE legal_entity_id = $1
ORDER BY id DESC
`

func (q *Queries) ListTenantsByLegalEntity(ctx context.Context, legalEntityID uuid.UUID) ([]Tenant, error) {
	rows, err := q.db.Query(ctx, listTenantsByLegalEntity, legalEntityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tenant{}
	for rows.Next() {
		var i Tenant
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.LegalName,
			&i.Country,
			&i.TenantKind,
			&i.ParentTenantID,
			&i.LegalEntityID,
			&i.TenantStatus,
			&i.KycLevel,
			&i.NettingEnabled,
			&i.NettingWindowMinutes,
			&i.ApiKeyHash,
			&i.WebhookUrl,
			&i.WebhookSecretHash,
			&i.Metadata,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTenantsByParent = `-- name: ListTenantsByParent :many
SELECT id, display_name, legal_name, country, tenant_kind, parent_tenant_id, legal_entity_id,
    tenant_status, kyc_level, netting_enabled, netting_window_minutes,
    api_key_hash, webhook_url, webhook_secret_hash, metadata, updated_at
FROM tenants
WHERE parent_tenant_id = $1
ORDER BY id DESC
`

func (q *Queries) ListTenantsByParent(ctx context.Context, parentTenantID pgtype.UUID) ([]Tenant, error) {
	rows, err := q.db.Query(ctx, listTenantsByParent, parentTenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tenant{}
	for rows.Next() {
		var i Tenant
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.LegalName,
			&i.Country,
			&i.TenantKind,
			&i.ParentTenantID,
			&i.LegalEntityID,
			&i.TenantStatus,
			&i.KycLevel,
			&i.NettingEnabled,
			&i.NettingWindowMinutes,
			&i.ApiKeyHash,
			&i.WebhookUrl,
			&i.WebhookSecretHash,
			&i.Metadata,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTenant = `-- name: UpdateTenant :one
UPDATE tenants SET
    display_name = COALESCE($1, display_name),
    legal_name = COALESCE($2, legal_name),
    tenant_status = COALESCE($3, tenant_status),
    kyc_level = COALESCE($4, kyc_level),
    netting_enabled = COALESCE($5, netting_enabled),
    netting_window_minutes = COALESCE($6, netting_window_minutes),
    webhook_url = COALESCE($7, webhook_url),
    metadata = COALESCE($8, metadata),
    updated_at = NOW()
WHERE id = $9
RETURNING id, display_name, legal_name, country, tenant_kind, parent_tenant_id, legal_entity_id,
    tenant_status, kyc_level, netting_enabled, netting_window_minutes,
    api_key_hash, webhook_url, webhook_secret_hash, metadata, updated_at
`

type UpdateTenantParams struct {
	DisplayName          pgtype.Text          `json:"display_name"`
	LegalName            pgtype.Text          `json:"legal_name"`
	TenantStatus         NullTenantStatusEnum `json:"tenant_status"`
	KycLevel             NullKycLevelEnum     `json:"kyc_level"`
	NettingEnabled       pgtype.Bool          `json:"netting_enabled"`
	NettingWindowMinutes pgtype.Int4          `json:"netting_window_minutes"`
	WebhookUrl           pgtype.Text          `json:"webhook_url"`
	Metadata             []byte               `json:"metadata"`
	ID                   uuid.UUID            `json:"id"`
}

func (q *Queries) UpdateTenant(ctx context.Context, arg UpdateTenantParams) (Tenant, error) {
	row := q.db.QueryRow(ctx, updateTenant,
		arg.DisplayName,
		arg.LegalName,
		arg.TenantStatus,
		arg.KycLevel,
		arg.NettingEnabled,
		arg.NettingWindowMinutes,
		arg.WebhookUrl,
		arg.Metadata,
		arg.ID,
	)
	var i Tenant
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.LegalName,
		&i.Country,
		&i.TenantKind,
		&i.ParentTenantID,
		&i.LegalEntityID,
		&i.TenantStatus,
		&i.KycLevel,
		&i.NettingEnabled,
		&i.NettingWindowMinutes,
		&i.ApiKeyHash,
		&i.WebhookUrl,
		&i.WebhookSecretHash,
		&i.Metadata,
		&i.UpdatedAt,
	)
	return i, err
}
